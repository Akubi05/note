# 1
栈帧是什么

## **栈帧（Stack Frame）详解**
**栈帧（Stack Frame）** 是 **函数调用** 时在 **栈（Stack）** 上分配的一块内存区域，它用于存储 **函数的参数、局部变量、返回地址** 以及 **保存的寄存器** 等信息。每当一个函数被调用时，CPU 会创建一个新的 **栈帧** 并压入栈中；当函数返回时，该栈帧会被弹出，恢复到调用它的函数。

---

## **1. 栈帧结构**
每个栈帧通常包含以下内容：

```
栈的高地址
+------------------+ <- 旧的 %rbp（前一个栈帧的基址）
|  调用者的 RBP    |
+------------------+ <- 当前函数的 %rbp
|  局部变量        |  (如 int a, int b 等)
|  临时数据        |  (如编译器生成的存储)
+------------------+
|  被调用函数参数  |  (如 sum(n-1) 的参数)
+------------------+
|  返回地址        |  (sum(n-1) 返回后执行的位置)
+------------------+ <- 当前函数的 %rsp（栈指针）
栈的低地址
```

- **`%rbp`（Base Pointer，基址指针）**
  - 存储 **调用该函数的栈帧基址**，用于访问局部变量和参数。
  - 进入新函数时，`push %rbp` 保存旧的 `rbp`，然后 `mov %rsp, %rbp` 让 `rbp` 指向新栈帧。

- **`%rsp`（Stack Pointer，栈指针）**
  - 指向 **当前栈的顶部**，每次 `push` 和 `call` 都会减少 `rsp` 的值（栈向下增长）。
  - 退出函数时 `leave`（`mov %rbp, %rsp` + `pop %rbp`）恢复栈。

---

## **2. `sum(n)` 的栈帧示例**
假设 `sum(3)` 递归调用 `sum(2) -> sum(1) -> sum(0)`，栈帧如下：

#### **`sum(3)` 进入时**
```
+------------------+  
|  sum(2) 返回地址  | <- `sum(3)` 调用 `sum(2)` 时 push
+------------------+  
|  旧的 %rbp（sum2）| <- `sum(3)` 进入前的栈帧基址
+------------------+  
|  局部变量 (n=3)  |
+------------------+
```

#### **`sum(2)` 进入时**
```
+------------------+  
|  sum(1) 返回地址  |
+------------------+  
|  旧的 %rbp（sum1）|
+------------------+  
|  局部变量 (n=2)  |
+------------------+
```

#### **`sum(1)` 进入时**
```
+------------------+  
|  sum(0) 返回地址  |
+------------------+  
|  旧的 %rbp（sum0）|
+------------------+  
|  局部变量 (n=1)  |
+------------------+
```

#### **`sum(0)` 进入时**
```
+------------------+  
|  返回地址（main） |
+------------------+  
|  旧的 %rbp（main）|
+------------------+  
|  局部变量 (n=0)  |
+------------------+
```

`sum(0)` 直接 `return 0`，然后 **栈帧依次弹出**，返回 `sum(1) -> sum(2) -> sum(3) -> main`。

---

## **3. 栈帧的创建和销毁**
当 `sum(n)` 被调用时，CPU 需要：
1. **保存前一个栈帧的基址** (`push %rbp`)
2. **建立新栈帧** (`mov %rsp, %rbp`)
3. **分配局部变量空间** (`sub $0x10, %rsp`)
4. **调用 `sum(n-1)`** (`call sum`)

当 `sum(n)` 返回时：
1. **恢复 `rbp`** (`leave`)
2. **弹出返回地址** (`ret`)

### **GDB 观察栈帧**
#### **查看当前栈帧**
```sh
(gdb) info frame
```

#### **查看调用栈**
```sh
(gdb) bt   # backtrace
```
示例输出：
```
#0  sum (n=0) at sum.c:6
#1  sum (n=1) at sum.c:8
#2  sum (n=2) at sum.c:8
#3  sum (n=3) at sum.c:8
#4  main () at sum.c:18
```
这表明 `sum(3)` 递归到了 `sum(0)`，并正在返回。

---

## **4. 栈溢出（Stack Overflow）**
- 由于每次递归都会创建新的 **栈帧**，**递归层数过深会导致栈空间耗尽**，触发 **"Segmentation Fault"**。
- **64 位 Linux 默认栈大小是 8MB**，假设每个 `sum` 栈帧占 **32 字节**，大约可递归：
  \[
  \frac{8 \times 1024 \times 1024}{32} = 262144
  \]
  **`sum(262144)` 就会栈溢出！**

#### **GDB 调试栈溢出**
```sh
(gdb) run
Please input n: 300000  # 过大，导致 Segmentation fault
```
```sh
(gdb) bt   # 查看溢出时的调用栈
```
```sh
(gdb) info proc map  # 查看栈大小
```
如果栈地址范围接近 8MB，说明触发了 **栈溢出（stack overflow）**。

---

## **5. 关键总结**
✅ **栈帧（Stack Frame）** 是 **函数执行时在栈上的内存区域**，用于存储：
   - **返回地址**
   - **旧的 `%rbp`（调用者栈帧指针）**
   - **局部变量**
   - **调用的函数参数**

✅ **递归调用时，每次都创建一个新的栈帧**，直到 `n==0` 终止递归并依次返回。

✅ **栈的默认大小是 8MB**，当 `sum(n)` 递归层数超过 `262144` 层时，会 **栈溢出**，导致 `Segmentation Fault`。

✅ **GDB 可用于分析栈帧**：
   - `bt` 查看 **调用栈**
   - `info frame` 查看 **当前栈帧**
   - `info proc map` 确认 **栈大小**

你可以自己试试在 GDB 里观察 `sum(n)` 的栈帧变化！🚀

---

# 2

在 GDB 调试递归函数 `sum(int n)` 时，我们可以深入分析它的 **栈帧分配**、**调用参数传递** 以及 **函数返回时栈的恢复** 过程。以下是详细的分解分析，包括 **汇编代码、栈帧内容、递归调用机制、返回时的恢复** 等关键点。

---

## **1. 递归调用 `sum(n)` 的执行流程**
C 代码：
```c
int sum(int n) {
   if (n == 0)
      return 0;
   else 
      return n + sum(n - 1);
}
```
**编译（64 位，带调试信息）：**
```sh
gcc -m64 -Og -g sum.c -o sum
gdb ./sum
```
---

## **2. 进入 `sum(n)` 函数**
### **函数前导代码**
当 `sum(n)` 被调用时，CPU 会执行 **函数前导代码**（prologue），用于保存旧的栈帧信息，并分配局部变量空间：

```assembly
push   %rbp           # 1. 保存旧的 %rbp（前一个函数栈帧的基址）
mov    %rsp, %rbp     # 2. 让 %rbp 指向当前函数的栈帧
sub    $0x10, %rsp    # 3. 预留局部变量空间（通常 16 字节对齐）
```
- `%rbp` 充当 **栈帧指针**，用于访问局部变量和函数参数。
- `%rsp` 充当 **栈指针**，用于动态管理栈空间。

---

## **3. 递归调用过程**
### **参数传递**
在 `x86_64` 体系结构中：
- **`sum(n)` 的参数 `n`** 通过 **寄存器 `%edi`** 传递（**System V ABI 规范**）。
- **递归调用 `sum(n-1)` 时**，会将 `n-1` 作为参数，放入 `%edi`，然后执行 `call sum`：
  
```assembly
mov    %edi, -0x4(%rbp)   # 1. 保存参数 n 到栈上（局部变量）
cmp    $0, %edi           # 2. 检查 n 是否为 0
je     return_zero        # 3. 若 n==0，则跳转到返回 0
sub    $1, %edi           # 4. 计算 n-1 作为递归参数
call   sum                # 5. 递归调用 sum(n-1)
```

- **`call sum`** 指令会：
  1. **把返回地址（`ret` 地址）压栈**。
  2. **跳转到 `sum` 入口**，开始新的递归调用。
  3. **重复上述栈帧创建过程**，直到 `n == 0` 为止。

---

## **4. 递归调用栈的增长**
假设 `sum(5)` 被调用，递归展开如下：

| 调用层次 | `n` 值 | 栈增长（`push` & `call`） | 返回地址存储位置 |
|---------|--------|--------------------------|----------------|
| `sum(5)` | `5` | `call sum(4)` 压栈 | `sum(5)` 返回地址 |
| `sum(4)` | `4` | `call sum(3)` 压栈 | `sum(4)` 返回地址 |
| `sum(3)` | `3` | `call sum(2)` 压栈 | `sum(3)` 返回地址 |
| `sum(2)` | `2` | `call sum(1)` 压栈 | `sum(2)` 返回地址 |
| `sum(1)` | `1` | `call sum(0)` 压栈 | `sum(1)` 返回地址 |
| `sum(0)` | `0` | **直接返回 0** | `sum(0)` 返回地址 |

此时 **栈已经存储了 6 个 `sum` 的返回地址**，且 `n=0` 触发了基准条件，开始 **返回计算**。

---

## **5. 递归返回过程**
当 `sum(0)` 计算完 `return 0;` 后，函数会**逐层返回**，执行 **函数后端代码**（epilogue），恢复栈帧并返回到上一层 `sum(n-1)`。

### **函数返回**
```assembly
mov    -0x4(%rbp), %eax  # 1. 取出局部变量（即 `sum(n-1)` 返回值）
add    %edi, %eax        # 2. 执行 `n + sum(n-1)`
leave                    # 3. 恢复栈帧（等价于 `mov %rbp, %rsp` + `pop %rbp`）
ret                      # 4. 弹出返回地址，并跳回上层调用者
```

- **`leave`** 指令：
  - `mov %rbp, %rsp`（释放局部变量空间）
  - `pop %rbp`（恢复上层函数的基址）
  
- **`ret` 指令**：
  - **从栈中弹出返回地址**，并跳转到调用 `sum(n-1)` 之后的指令。

这样，每层递归都**返回 `n + sum(n-1)`，逐步计算最终值**。

---

## **6. 递归栈空间计算**
**在 64 位 Linux 下，默认用户栈大小是 8MB**，我们可以计算 `sum` 能递归的最大 `n`。

- **单个 `sum` 栈帧大小 ≈ 32 字节**（局部变量 + 对齐）
- **最大可用栈空间 ≈ 8MB = 8 * 1024 * 1024 字节**
- **可容纳的栈帧数**：
  
\[
\frac{8 \times 1024 \times 1024}{32} = 262144
\]

即 **当 `n ≈ 262144` 时，递归调用会耗尽栈空间，发生 `stack overflow`**。

---

## **7. GDB 调试栈溢出**
### **（1）运行并触发栈溢出**
```sh
(gdb) run
Please input n: 300000  # 输入一个很大的 n
```
程序可能会报 `Segmentation fault (core dumped)`，表示栈空间溢出。

---

### **（2）查看异常发生的递归深度**
```sh
(gdb) bt  # backtrace 查看调用栈
```
输出可能类似：
```
#0  sum (n=1) at sum.c:8
#1  sum (n=2) at sum.c:8
#2  sum (n=3) at sum.c:8
...
#262144 sum (n=262144) at sum.c:8
```
**说明 `sum(n)` 递归到了 `262144` 次，栈空间已耗尽！**

---

### **（3）计算栈溢出前 `rsp` 的位置**
在 `main` 调用 `sum` 之前，查看 `rsp`：
```sh
(gdb) p $rsp
```
在溢出时，查看 `rsp`：
```sh
(gdb) b sum if n==262144
(gdb) p $rsp
```
计算：
\[
\text{栈增长量} = \text{初始 } rsp - \text{溢出时 } rsp
\]
如果接近 8MB，则说明递归确实耗尽了栈空间。

---

## **8. 结论**
1. **每次递归调用 `sum(n-1)`，都会创建新的栈帧**，保存 `n` 和返回地址。
2. **64 位 Linux 默认栈大小为 8MB，`sum(n)` 约能递归 262144 次后崩溃**。
3. **通过 GDB `bt` 命令，我们可以找到 `n` 恰好溢出的具体值**。
4. **栈空间按 4KB 页分配**，每 4KB 触发一次 `page fault`，GDB 可用 `info proc map` 查看栈增长。

你可以尝试自己调试 `sum(n)`，看看你的系统具体能支持多少层递归！🚀