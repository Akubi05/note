# 0. 编译指令
`disassemble main [/m]`
/m c和asm一起排列   
/r 看16进制代码 
gcc -O0 -no-pie -ggdb floatequ.c -o floatequ
gcc -m32 -O0 -no-pie -g memory.c -o m32
gcc -O0 -no-pie -g memory.c -o m
# 1. p的格式化打印
在 `gdb` 中，`p`（`print`）命令支持多种格式化打印方式，常见的格式前缀如下：  

| 格式前缀  | 说明                    | 示例 |
|----------|----------------------|----------------------------|
| `/x`     | 以 **十六进制** 输出    | `p/x $rsp` -> `0x7ffffffde000` |
| `/d`     | 以 **十进制** 输出      | `p/d n` -> `1234` |
| `/u`     | 以 **无符号十进制** 输出 | `p/u n` -> `4294967295` |
| `/o`     | 以 **八进制** 输出      | `p/o n` -> `0177777` |
| `/t`     | 以 **二进制** 输出      | `p/t n` -> `0b101010` |
| `/c`     | 以 **字符** 输出        | `p/c ch` -> `'A'` |
| `/s`     | 以 **字符串** 输出      | `p/s str` -> `"hello"` |
| `/a`     | 以 **地址** 输出        | `p/a ptr` -> `0x555555554000` |

---

## **示例**
### **1. 打印寄存器的十六进制值**
```gdb
(gdb) p/x $rsp
$1 = 0x7ffffffde000
```

### **2. 打印变量的不同格式**
```c
int n = 42;
char ch = 'A';
char str[] = "hello";
```
```gdb
(gdb) p/x n   # 十六进制
$2 = 0x2a
(gdb) p/d n   # 十进制
$3 = 42
(gdb) p/t n   # 二进制
$4 = 0b101010
(gdb) p/o n   # 八进制
$5 = 052
(gdb) p/c ch  # 字符
$6 = 'A'
(gdb) p/s str # 字符串
$7 = "hello"
```

### **3. 打印指针的地址**
```gdb
(gdb) p/a &n
$8 = 0x7fffffffdc4c
```

---

## **额外技巧**
如果你想一次打印多个变量：
```gdb
(gdb) print/x n, ch, &n
$9 = 0x2a
$10 = 0x41
$11 = (int *) 0x7fffffffdc4c
```
你也可以用 `set print` 命令来全局修改默认的格式：
```gdb
(gdb) set print pretty on   # 让结构体、数组等打印得更美观
(gdb) set print elements 10 # 限制数组打印的元素个数
```

如果你想每次都默认以 **十六进制** 打印：
```gdb
(gdb) set output-radix 16
```
这样后续的 `p` 命令都会以 **十六进制** 显示。

---

### **总结**
- **常用格式**：`p/x`（十六进制），`p/d`（十进制），`p/t`（二进制），`p/o`（八进制）。
- **字符串** 用 `p/s`，**字符** 用 `p/c`，**地址** 用 `p/a`。
- **可以全局修改默认格式**，用 `set output-radix 16` 让所有输出默认使用十六进制。

这样你就可以更方便地分析 `gdb` 里的数据啦！🚀

# 2. 优化级别

在 GCC（GNU Compiler Collection）等编译器中，`-O0`、`-O1`、`-O2`、`-O3`、`-Og` 等优化级别用于控制编译器对代码进行的优化程度。不同的优化级别会影响代码的执行速度、代码大小以及调试信息的可用性。

---

## 1. `-O0`（无优化）
- **特点**：
  - 完全不进行优化，保持代码尽可能接近源代码逻辑。
  - 变量不会被寄存器替代，所有变量都存储在内存中。
  - 适用于 **调试**，因为可直接映射到源代码的每一行。
  - 代码执行速度较慢，程序体积较大。
  
- **使用场景**：
  - 代码开发阶段，便于调试。
  - 需要查看完整的反汇编代码以研究内存布局。

---

## 2. `-Og`（适用于调试的优化）
- **特点**：
  - 适用于调试的优化级别（"Optimization for debugging"）。
  - 进行部分优化，使代码运行更高效，同时保留大部分调试信息。
  - 比 `-O0` 生成的代码更快，但仍然适合单步调试。

- **使用场景**：
  - 需要调试的情况下，想要一定的优化但又不能影响调试过程。

---

## 3. `-O1`（基本优化）
- **特点**：
  - 进行基本优化，减少代码大小，提高执行效率。
  - 可能会进行 **常量合并、死代码消除、简单循环优化** 等优化。
  - 代码仍然比较容易调试，但可能不会与源代码 1:1 对应。

- **使用场景**：
  - 适用于需要一定优化但仍然要保持代码可读性的情况。
  - 一般用于开发阶段的 **测试版本**。

---

## 4. `-O2`（常用优化）
- **特点**：
  - 进行 **更高级的优化**，使程序运行更快。
  - 包括：
    - **循环优化**（如展开循环、减少分支）
    - **指令调度**（减少流水线阻塞）
    - **消除不必要的存储和加载操作**
    - **减少栈使用**
  - 代码体积通常比 `-O1` 更小，执行速度更快。

- **使用场景**：
  - **推荐用于生产环境**，因为它能大幅提升性能且不会激进地优化代码（不会影响程序行为）。

---

## 5. `-O3`（最高级优化）
- **特点**：
  - 在 `-O2` 的基础上进行更激进的优化：
    - **自动向量化**（SIMD）
    - **更激进的函数内联**
    - **冗余计算消除**
    - **更强的循环优化**
  - 可能会改变某些代码的行为（如未定义行为）。
  - 代码执行速度最快，但可能增加程序体积。

- **使用场景**：
  - 需要极致性能优化的场合，如 **科学计算、高性能服务器**。
  - 可能会导致某些代码难以调试或行为改变。

---

## 6. `-Ofast`（超激进优化）
- **特点**：
  - 在 `-O3` 基础上，**忽略 IEEE 754 浮点数标准**，进行更激进的优化：
    - **去除 NaN 和无穷大检查**
    - **允许浮点数计算重排序**
    - **忽略严格的标准要求**
  - **可能导致数值计算不准确**，但速度更快。

- **使用场景**：
  - 适用于 **高性能计算**，但不适用于需要严格数值精度的应用（如金融、密码学）。

---

## 7. `-Os`（优化代码大小）
- **特点**：
  - 在 `-O2` 的基础上进一步优化 **代码大小**，减少指令数量。
  - 适用于 **嵌入式系统、存储受限的环境**。

- **使用场景**：
  - 适合 **嵌入式设备** 或 **存储受限的环境**。

---

## 8. `-Oz`（极致优化代码大小）
- **特点**：
  - 在 `-Os` 基础上 **进一步优化代码体积**，可能牺牲一些性能。

- **使用场景**：
  - **极端存储受限的设备**，如 **微控制器**。

---

## **优化级别总结**
| 选项 | 适用场景 | 主要优化内容 | 适合调试 | 代码大小 | 代码执行速度 |
|------|---------|-------------|---------|---------|---------|
| `-O0` | 调试、分析 | 无优化 | ✅ | 大 | 慢 |
| `-Og` | 调试 + 轻微优化 | 适合调试的优化 | ✅ | 较大 | 较快 |
| `-O1` | 代码优化但仍可调试 | 基本优化 | ⚠️ | 中 | 中等 |
| `-O2` | 生产环境推荐 | 标准优化（循环、指令调度等） | ❌ | 小 | 快 |
| `-O3` | 高性能应用 | 激进优化（自动向量化、函数内联等） | ❌ | 大 | 更快 |
| `-Ofast` | 超高性能计算 | `-O3` + 浮点优化（可能不精确） | ❌ | 大 | 最快 |
| `-Os` | 嵌入式系统 | `-O2` + 代码缩减 | ⚠️ | 更小 | 快 |
| `-Oz` | 极端存储受限 | `-Os` + 进一步缩小代码 | ❌ | 最小 | 快 |

---

## **如何选择优化级别？**
- **调试时**：使用 `-O0` 或 `-Og`，这样可以更容易追踪代码执行路径。
- **一般开发**：`-O1` 既有优化，又不会改变代码结构太多。
- **生产环境**：`-O2` 是**推荐**的优化级别，能显著提升性能且不会太激进。
- **高性能计算**：`-O3` 或 `-Ofast`，但 `-Ofast` 可能会影响浮点计算的正确性。
- **存储受限环境**：使用 `-Os` 或 `-Oz` 以减少代码体积。

如果你的程序涉及 **浮点计算** 并且要求严格的计算精度，请避免 `-Ofast`，因为它会违反 IEEE 754 标准。

---

你现在的 `float` 计算实验，推荐使用 `-O0` 进行测试，确保 `printf` 输出的结果不会受到优化影响。而如果要分析优化后的汇编代码，可以尝试 `-O1`、`-O2` 进行对比。

# 3. 常用调试指令

在 `gdb` 调试时，以下是常用的命令，涵盖 **基本调试、断点、内存查看、寄存器分析、汇编调试** 等方面。

---

## **1. 启动和加载**
```bash
gdb ./a.out      # 启动 GDB 并加载可执行文件
gdb -tui ./a.out # 启动 TUI 界面（带有代码和汇编窗口）
```
在 `gdb` 中运行程序：
```gdb
(gdb) run        # 运行程序
(gdb) run arg1 arg2   # 运行程序并传入参数
(gdb) start      # 运行程序并在 `main` 处停下
```

---

## **2. 断点（Breakpoints）**
```gdb
(gdb) break main              # 在 main 函数处设断点
(gdb) break 42                # 在第 42 行设断点
(gdb) break file.c:42         # 在 file.c 文件的第 42 行设断点
(gdb) break func_name         # 在 func_name 处设断点
(gdb) tbreak func_name        # 仅触发一次的断点
(gdb) rbreak prefix.*         # 设置所有匹配 prefix 开头的函数断点
(gdb) delete 1                # 删除编号 1 的断点
(gdb) info breakpoints        # 显示所有断点
```

---

## **3. 运行控制**
```gdb
(gdb) continue    # 继续执行到下一个断点
(gdb) next        # 执行当前行（不进入函数）
(gdb) step        # 进入函数内部执行
(gdb) finish      # 运行到当前函数返回
(gdb) until 42    # 运行到第 42 行
(gdb) return      # 直接返回当前函数（可能导致程序异常）
(gdb) kill        # 终止程序
```

---

## **4. 查看变量**
```gdb
(gdb) print a             # 打印变量 a 的值
(gdb) print/x a           # 以十六进制显示变量 a
(gdb) print/t a           # 以二进制显示变量 a
(gdb) print &a            # 查看 a 的地址
(gdb) whatis a            # 查看变量 a 的类型
(gdb) info locals         # 显示所有局部变量
(gdb) info args           # 显示当前函数的参数
(gdb) display a           # 每次停止时自动显示 a
(gdb) undisplay 1         # 取消自动显示编号 1
```

---

## **5. 查看内存**
```gdb
(gdb) x/10d &a           # 查看 a 的内存地址处的 10 个十进制值
(gdb) x/5x 0x602010      # 查看 0x602010 地址处的 5 个十六进制数
(gdb) x/20b buf          # 查看 buf 的 20 个字节（以二进制显示）
(gdb) x/s ptr            # 查看 ptr 指向的字符串
(gdb) x/4i $pc           # 查看当前 PC 指令的 4 条汇编代码
```

格式说明：
- `d` = decimal（十进制）
- `x` = hex（十六进制）
- `b` = byte（字节）
- `s` = string（字符串）
- `i` = instruction（指令）

---

## **6. 查看寄存器**
```gdb
(gdb) info registers       # 显示所有寄存器值
(gdb) info all-registers   # 显示所有寄存器，包括 FP、XMM、SSE
(gdb) print $rax           # 查看 rax 寄存器
(gdb) set $eax=0x1234      # 修改 eax 寄存器的值
```

---

## **7. 汇编调试**
```gdb
(gdb) disassemble main      # 反汇编 main 函数
(gdb) disassemble /m main   # 显示 C 代码和汇编混合
(gdb) disassemble /r main   # 显示十六进制指令
(gdb) stepi                # 执行一条汇编指令
(gdb) nexti                # 执行一条汇编指令（不进入调用）
```

---

## **8. 栈和函数调用**
```gdb
(gdb) backtrace         # 显示调用栈（当前执行路径）
(gdb) bt                # backtrace 的简写
(gdb) bt full           # 显示完整调用栈（包含变量）
(gdb) frame 2           # 切换到第 2 帧
(gdb) up                # 向上移动一帧（上一层函数）
(gdb) down              # 向下移动一帧（下一层函数）
```

---

## **9. 修改变量**
```gdb
(gdb) set var a=10       # 修改变量 a 的值
(gdb) set *(int*)0x602010 = 42   # 修改内存地址处的值
(gdb) set $rax=0x1234    # 修改寄存器值
```

---

## **10. 调试共享库**
```gdb
(gdb) info sharedlibrary   # 显示加载的共享库
(gdb) break function@lib.so  # 在共享库的函数处设断点
(gdb) set environment LD_PRELOAD ./mylib.so  # 预加载动态库
```

---

## **11. 条件断点**
```gdb
(gdb) break 42 if x==5     # 当 x == 5 时，在第 42 行断点
(gdb) condition 1 x>10     # 让断点 1 仅在 x > 10 时触发
```

---

## **12. 记录 & 复现**
```gdb
(gdb) record              # 开始记录执行路径
(gdb) record stop         # 停止记录
(gdb) reverse-continue    # 逆向执行（回溯）
(gdb) reverse-step        # 逆向单步调试
(gdb) reverse-finish      # 逆向执行到函数返回
```

---

## **13. 保存和加载调试会话**
```gdb
(gdb) save breakpoints bps.txt  # 保存断点
(gdb) source bps.txt            # 重新加载断点
```

---

### **总结**
📌 **基本操作**
- `run` / `continue` / `next` / `step` / `finish`
- `break` / `delete` / `info breakpoints`
- `print` / `x` / `info registers`
- `backtrace` / `frame` / `up` / `down`

📌 **高级操作**
- `disassemble` / `stepi`
- `record` / `reverse-continue`
- `set var` / `set $rax`

这些命令可以让你 **更高效地调试 C 代码、分析内存布局、逆向工程**！🚀

# 4 同时查看c与汇编

推荐使用layout split

在 GDB 中，可以使用 `disassemble /m` 或 `layout split` 来同时显示 **C 代码** 和 **汇编代码**。以下是具体方法：

---

## **方法 1：使用 `disassemble /m`**
可以让 GDB **混合显示 C 代码和汇编指令**：
```gdb
disassemble /m main
```
🔹 说明：
- `disassemble /m` 以 **混合模式（mixed mode）** 显示 C 代码和对应的汇编指令。  
- `main` 可以替换成你想要查看的函数名。

如果想要显示 16 进制指令：
```gdb
disassemble /r main
```
这样会在汇编代码后面 **附带十六进制机器码**，便于分析。

---

## **方法 2：使用 `layout split`（TUI 界面）**
如果你想 **实时动态查看** C 代码和汇编代码，可以进入 GDB 的 TUI（Text User Interface）模式：
```gdb
layout split
```
🔹 说明：
- `layout split` **上方显示 C 代码，下方显示汇编代码**。
- 你可以用 `stepi` 逐条执行指令，并实时看到 C 代码和汇编的变化。

如果只想显示汇编代码：
```gdb
layout asm
```
如果想回到普通 GDB 命令行模式：
```gdb
layout reg
```

---

## **方法 3：开启 `set disassemble` 自动混合模式**
如果想在每次 `stepi` 时自动显示 C 代码和汇编：
```gdb
set disassemble-next-line on
```
这样，每次单步执行（`stepi`）时，GDB 都会显示当前执行的 C 代码和汇编代码。

如果你不想要这个功能：
```gdb
set disassemble-next-line off
```

---

## **总结**
| **方法**                  | **命令**                 | **特点** |
|---------------------------|-------------------------|---------|
| **混合显示 C 和汇编**     | `disassemble /m main`   | 只显示某个函数的 C 代码 + 汇编 |
| **显示 16 进制指令**      | `disassemble /r main`   | 带机器码的汇编 |
| **动态窗口模式**          | `layout split`          | C 代码 + 汇编分屏显示 |
| **纯汇编模式**            | `layout asm`            | 只显示汇编 |
| **自动显示 C+汇编**       | `set disassemble-next-line on` | `stepi` 时自动显示 C 和汇编 |

如果你想 **边调试边看到 C 和汇编**，建议使用：
```gdb
layout split
stepi  # 单步执行汇编指令
```
这样可以 **实时观察 C 代码和对应的汇编指令**，非常适合学习和分析！ 🚀

# 5. layout使用

在 **GDB TUI（Text User Interface）模式** 中，`layout` 命令用于 **改变窗口布局**，可以选择显示 **C 代码、汇编、寄存器等信息**。

---

## **1. `layout` 命令的格式**
```gdb
layout <layout_name>
```
或者：
```gdb
layout prev   # 切换到上一个布局
layout next   # 切换到下一个布局
```

其中，`<layout_name>` 取值如下：
| **布局名称** | **功能** |
|-------------|---------|
| `src`       | **只显示 C 代码** |
| `asm`       | **只显示汇编代码** |
| `split`     | **同时显示 C 代码和汇编代码** |
| `regs`      | **显示寄存器** |

---

## **2. 具体布局介绍**
### **🔹 `layout src`（源码模式）**
```gdb
layout src
```
- 只显示 C 代码，不显示汇编。
- 适合高级语言调试，不关注底层汇编。

---

### **🔹 `layout asm`（汇编模式）**
```gdb
layout asm
```
- 只显示 **汇编指令**，不显示 C 代码。
- 适合调试底层汇编，逐步跟踪寄存器变化。

---

### **🔹 `layout split`（源码+汇编模式）**
```gdb
layout split
```
- **上半部分** 显示 C 代码，**下半部分** 显示对应的汇编代码。
- 适合想同时查看 C 代码和汇编代码的情况。

---

### **🔹 `layout regs`（寄存器模式）**
```gdb
layout regs
```
- 显示 CPU **所有寄存器**。
- 适合分析寄存器变化，例如 `eax`、`rsp`、`rbp` 等。

---

## **3. 切换布局**
- `layout prev`：回到上一个布局。
- `layout next`：切换到下一个布局。

示例：
```gdb
layout split  # 切换到 C 代码 + 汇编模式
layout regs   # 切换到寄存器模式
layout prev   # 回到上一个布局
layout next   # 切换到下一个布局
```

---

## **4. 结合 `stepi` 进行调试**
```gdb
layout split      # 同时显示 C 代码和汇编
set disassemble-next-line on  # 让 GDB 自动显示当前汇编指令
start             # 运行程序
stepi             # 逐步执行一条汇编指令
info registers    # 查看寄存器状态
```
---

## **总结**
| **命令**        | **作用** |
|----------------|---------|
| `layout src`   | 只显示 C 代码 |
| `layout asm`   | 只显示汇编代码 |
| `layout split` | C 代码 + 汇编 |
| `layout regs`  | 显示寄存器 |
| `layout prev`  | 切换到上一个布局 |
| `layout next`  | 切换到下一个布局 |

如果你想同时查看 C 代码和汇编，并进行单步调试：
```gdb
layout split
stepi
info registers
```
这样你就可以 **精准控制每条指令的执行**！🚀
