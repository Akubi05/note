# 1. phase_1 字符串比较
```
Dump of assembler code for function phase_1:
=> 0x00000000004013f9 <+0>:     push   %rbp
   0x00000000004013fa <+1>:     mov    %rsp,%rbp
   0x00000000004013fd <+4>:     mov    $0x403150,%esi
   0x0000000000401402 <+9>:     call   0x401849 <strings_not_equal>
   0x0000000000401407 <+14>:    test   %eax,%eax
   0x0000000000401409 <+16>:    jne    0x40140d <phase_1+20>
   0x000000000040140b <+18>:    pop    %rbp
   0x000000000040140c <+19>:    ret
   0x000000000040140d <+20>:    call   0x401945 <explode_bomb>
   0x0000000000401412 <+25>:    jmp    0x40140b <phase_1+18>
```

# 2. phase_2 循环

```
Dump of assembler code for function phase_2:
=> 0x0000000000401414 <+0>:     push   %rbp
   0x0000000000401415 <+1>:     mov    %rsp,%rbp
   0x0000000000401418 <+4>:     push   %rbx
   0x0000000000401419 <+5>:     sub    $0x28,%rsp
   0x000000000040141d <+9>:     lea    -0x30(%rbp),%rsi
   0x0000000000401421 <+13>:    call   0x401967 <read_six_numbers>
   0x0000000000401426 <+18>:    cmpl   $0x0,-0x30(%rbp)
   0x000000000040142a <+22>:    js     0x401433 <phase_2+31>
   0x000000000040142c <+24>:    mov    $0x1,%ebx
   0x0000000000401431 <+29>:    jmp    0x401442 <phase_2+46>
   0x0000000000401433 <+31>:    call   0x401945 <explode_bomb>
   0x0000000000401438 <+36>:    jmp    0x40142c <phase_2+24>
   0x000000000040143a <+38>:    call   0x401945 <explode_bomb>
   0x000000000040143f <+43>:    add    $0x1,%ebx
   0x0000000000401442 <+46>:    cmp    $0x5,%ebx
   0x0000000000401445 <+49>:    jg     0x40145e <phase_2+74>
   0x0000000000401447 <+51>:    movslq %ebx,%rax
   0x000000000040144a <+54>:    lea    -0x1(%rbx),%edx
   0x000000000040144d <+57>:    movslq %edx,%rdx
   0x0000000000401450 <+60>:    mov    %ebx,%ecx
   0x0000000000401452 <+62>:    add    -0x30(%rbp,%rdx,4),%ecx
   0x0000000000401456 <+66>:    cmp    %ecx,-0x30(%rbp,%rax,4)
   0x000000000040145a <+70>:    je     0x40143f <phase_2+43>
   0x000000000040145c <+72>:    jmp    0x40143a <phase_2+38>
   0x000000000040145e <+74>:    add    $0x28,%rsp
   0x0000000000401462 <+78>:    pop    %rbx
   0x0000000000401463 <+79>:    pop    %rbp
   0x0000000000401464 <+80>:    ret
End of assembler dump.
```

## 栈空间过程

好的，我们来详细分析 **`phase_2`** 执行过程中的 **栈变换**，追踪**栈指针（`rsp`）**和**栈内容的变化**。  

---

## **1. 进入 `phase_2` 时的栈**
进入 `phase_2` 之前，`main` 调用了 `phase_2`，此时 `rsp` 指向调用者的返回地址（即 `main` 的下一条指令）。

```
+--------------------+  <-- 初始 rsp
| main 返回地址      |  
+--------------------+
```

执行 `push %rbp` 和 `mov %rsp, %rbp`：
```
+--------------------+  
| main 返回地址      |  
+--------------------+  <-- rbp (保存 main 的栈帧)
| 旧 rbp             |  <-- 新的 rbp
+--------------------+  <-- rsp
```

---

## **2. 进入 `phase_2` 后的栈变换**
### **(1) 保存 `rbx`**
```assembly
push   %rbx
```
- `rbx` 可能被修改，因此先保存到栈上：
```
+--------------------+  
| main 返回地址      |  
+--------------------+  <-- rbp
| 旧 rbp             |  
+--------------------+  
| 旧 rbx             |  <-- rsp
+--------------------+
```

---

### **(2) 申请局部变量（数组 `A[6]`）**
```assembly
sub $0x28, %rsp
```
- 申请 `0x28 = 40` 字节的栈空间（6 个 `int` 数组 `A[6]` + 对齐）。
```
+--------------------+  
| main 返回地址      |  
+--------------------+  <-- rbp
| 旧 rbp             |  
+--------------------+  
| 旧 rbx             |  
+--------------------+  
| A[5]              |  
+--------------------+  
| A[4]              |  
+--------------------+  
| A[3]              |  
+--------------------+  
| A[2]              |  
+--------------------+  
| A[1]              |  
+--------------------+  
| A[0]              |  <-- rsp
+--------------------+
```

---

### **(3) 读取 6 个整数**
```assembly
lea -0x30(%rbp), %rsi
call read_six_numbers
```
- `read_six_numbers` 将 6 个整数存入 `A[0] ~ A[5]`。

**假设用户输入**：
```
0 1 3 6 10 15
```
那么 `A[0]` ~ `A[5]` 的值：
```
+--------------------+  
| main 返回地址      |  
+--------------------+  <-- rbp
| 旧 rbp             |  
+--------------------+  
| 旧 rbx             |  
+--------------------+  
| 15                |  <-- A[5]
+--------------------+  
| 10                |  <-- A[4]
+--------------------+  
| 6                 |  <-- A[3]
+--------------------+  
| 3                 |  <-- A[2]
+--------------------+  
| 1                 |  <-- A[1]
+--------------------+  
| 0                 |  <-- A[0], rsp
+--------------------+
```
### ** `-0x30(%rbp)` 的含义**
`-0x30(%rbp)` 是**基址寻址**模式，它的计算方式是：
\[
\text{计算出的地址} = \text{rbp} + (-0x30)
\]
也就是说，它计算 `rbp` 向下偏移 `0x30`（即 48 字节）的地址。

在 `phase_2` 代码中，我们看到：
```assembly
sub $0x28, %rsp  # 申请 0x28 (40) 字节的栈空间
```
说明栈上分配了局部变量的空间，而 `-0x30(%rbp)` 指向的是 **数组 `A[6]` 的首地址**。

---

### ** `lea -0x30(%rbp), %rsi` 作用**
这条指令的作用是：
- **计算** `A[0]` 的地址（即 `rbp - 0x30`）。
- **存入** `rsi` 作为 `read_six_numbers` 的参数。

在 x86-64 体系中，**函数调用时，第一个参数传给 `rdi`，第二个参数传给 `rsi`**。而 `read_six_numbers` 需要一个**存储 6 个整数的地址**，所以：
```assembly
lea -0x30(%rbp), %rsi  # rsi = &A[0]
call 0x401967 <read_six_numbers>
```
等效于：
```c
int A[6];  
read_six_numbers(&A[0]);  // 传递数组的首地址
```
---
---

## **3. 递推关系检查的栈变换**
### **(1) 读取 `A[0]` 并检查是否小于 0**
```assembly
cmpl $0x0, -0x30(%rbp)   # 检查 A[0]
js explode_bomb
```
如果 `A[0] < 0`，会调用 `explode_bomb` 引爆炸弹，否则继续。

---

### **1. 初始化循环变量**
```assembly
0x000000000040142c <+24>:    mov    $0x1,%ebx
```
- `ebx` 作为循环变量 `i`，初始值 `1`。
- **对应的 C 代码**：
  ```c
  int i = 1;
  ```

---

### **2. 进入循环**
```assembly
0x0000000000401431 <+29>:    jmp    0x401442 <phase_2+46>
```
- **跳转到循环检查部分**（`cmp $0x5, %ebx`）。
- **这里是 `do-while` 形式**，因为 `jmp` 直接跳过了判断，先执行一次循环体。

---

### **3. 递推关系检查**
```assembly
0x0000000000401442 <+46>:    cmp    $0x5,%ebx
0x0000000000401445 <+49>:    jg     0x40145e <phase_2+74>
```
- **循环条件**：
  ```c
  if (i > 5) exit;
  ```
- **当 `i > 5` 时，跳出循环，执行清理并返回。**

---

### **4. 计算 `A[i] = A[i-1] + i`**
```assembly
0x0000000000401447 <+51>:    movslq %ebx,%rax
0x000000000040144a <+54>:    lea    -0x1(%rbx),%edx
0x000000000040144d <+57>:    movslq %edx,%rdx
```
- `movslq %ebx, %rax`：
  - `i`（存于 `ebx`）转换为 64 位，存入 `rax`，用于索引 `A[i]`。
- `lea -0x1(%rbx), %edx`：
  - `edx = i - 1`（计算 `A[i-1]` 的索引）。
- `movslq %edx, %rdx`：
  - `rdx = i - 1`（转换为 64 位）。

---

### **5. 计算 `A[i-1] + i`**
```assembly
0x0000000000401450 <+60>:    mov    %ebx,%ecx
0x0000000000401452 <+62>:    add    -0x30(%rbp,%rdx,4),%ecx
```
- **为什么缩放因子是 4？**
  - A 是 int 类型数组，而 每个 int 占 4 字节。
  - rdx 存储的是 i-1，即 A[i-1] 的索引。
  - 由于 int 占 4 字节，所以 rdx 必须乘以 4 才能正确计算 A[i-1] 在内存中的位置。
    
    
    

- `mov %ebx, %ecx`：
  - `ecx = i`
- `add -0x30(%rbp,%rdx,4), %ecx`：
  - `ecx = A[i-1] + i`
  - **等价于**：
    ```c
    temp = A[i-1] + i;
    ```

---

### **6. 比较 `A[i]` 与 `A[i-1] + i`**
```assembly
0x0000000000401456 <+66>:    cmp    %ecx,-0x30(%rbp,%rax,4)
```
- **检查 `A[i]` 是否等于 `A[i-1] + i`**
  ```c
  if (A[i] != A[i-1] + i) explode_bomb();
  ```

---

### **7. 处理错误情况**
```assembly
0x000000000040145a <+70>:    je     0x40143f <phase_2+43>
0x000000000040145c <+72>:    jmp    0x40143a <phase_2+38>
```
- `je`（Jump if Equal）：
  - 如果 `A[i] == A[i-1] + i`，跳转到 `0x40143f` 继续循环。
  - **否则跳转到 `0x40143a`，调用 `explode_bomb()`**。

---

### **8. 递增 `i`**
```assembly
0x000000000040143f <+43>:    add    $0x1,%ebx
```
- `i++`
- **继续下一轮循环**。

---

### **9. 退出循环**
```assembly
0x000000000040145e <+74>:    add    $0x28,%rsp
0x0000000000401462 <+78>:    pop    %rbx
0x0000000000401463 <+79>:    pop    %rbp
0x0000000000401464 <+80>:    ret
```
- **恢复栈并返回**。

---

### **对应的 C 代码**
完整的 **C 语言等价代码**：
```c
void phase_2() {
    int A[6]; 
    read_six_numbers(A);
    
    if (A[0] < 0) explode_bomb();

    int i = 1;
    while (i <= 5) {
        if (A[i] != A[i-1] + i) 
            explode_bomb();
        i++;
    }
}
```
---

### **总结**
1. **`i = 1` 作为循环变量。**
2. **循环检查 `i ≤ 5`，否则退出。**
3. **检查 `A[i] == A[i-1] + i`，否则触发炸弹。**
4. **如果通过，`i++`，继续循环。**
5. **所有检查通过，函数返回。**

---

**示例输入**（满足 `A[i] = A[i-1] + i`）：
```
0 1 3 6 10 15
```
- `A[1] = 0 + 1`
- `A[2] = 1 + 2`
- `A[3] = 3 + 3`
- `A[4] = 6 + 4`
- `A[5] = 10 + 5`
- **不会触发 `explode_bomb`，顺利返回！**

如果输入 `0 1 3 6 9 15`（错误）：
- `A[4] = 9` 但 `A[3] + 4 = 10`
- **触发炸弹！**

---

---

## **4. 退出 `phase_2` 的栈恢复**
### **(1) 释放局部变量**
```assembly
add $0x28, %rsp
```
- `rsp` 回到 `rbx` 位置：
```
+--------------------+  
| main 返回地址      |  
+--------------------+  <-- rbp
| 旧 rbp             |  
+--------------------+  
| 旧 rbx             |  <-- rsp
+--------------------+
```

---

### **(2) 恢复 `rbx` 和 `rbp`**
```assembly
pop %rbx
pop %rbp
```
- `rbp` 恢复为 `main` 的栈帧：
```
+--------------------+  
| main 返回地址      |  <-- rsp
+--------------------+
```

---

### **(3) 返回 `main`**
```assembly
ret
```
- **函数返回，栈恢复正常**。

---

## **总结**
**栈变化过程总结**：
1. 进入 `phase_2`：
   - 保存 `rbp`，申请 `A[6]` 变量空间。
2. 调用 `read_six_numbers`：
   - 读取 6 个数存入 `A[0] ~ A[5]`。
3. 递推检查：
   - `A[i] = A[i-1] + i`，如有错误调用 `explode_bomb`。
4. 退出 `phase_2`：
   - 释放栈空间，恢复 `rbp` 和 `rbx`，返回 `main`。

---

### **示例：用户输入 `0 1 3 6 10 15`**
- 满足递推关系，正常返回。
- 若输入 `0 1 3 6 9 15`：
  - `A[4] = 9` 不满足 `A[4] = A[3] + 4`（`6 + 4 != 9`），**触发 `explode_bomb`**！

---

**希望这个栈分析对你有帮助！有什么不明白的地方吗？😃**

# 3. phase_3 if/switch

## **汇编代码解析（Phase 3）**

这段汇编代码是 `phase_3` 函数，属于一个 **炸弹（bomb）解密** 程序的一部分。它的主要逻辑是：

1. **读取两个用户输入的整数**。
2. **第一个整数用于索引跳转到不同的分支**。
3. **计算一个目标值**，然后比较输入的第二个整数是否匹配目标值。
4. **如果匹配，继续执行；否则爆炸（`explode_bomb`）**。

---

## **1. 栈帧布局**
函数开头：
```assembly
0x0000000000401465 <+0>:   push   %rbp
0x0000000000401466 <+1>:   mov    %rsp,%rbp
0x0000000000401469 <+4>:   sub    $0x10,%rsp
```
- **`push %rbp`**：保存上一层 `rbp`。
- **`mov %rsp, %rbp`**：设置当前 `rbp` 为栈底。
- **`sub $0x10, %rsp`**：给局部变量分配 16 字节空间。

局部变量：
- `-0x4(%rbp)`：存储第一个输入整数。
- `-0x8(%rbp)`：存储第二个输入整数。

---

## **2. 读取输入**
```assembly
0x000000000040146d <+8>:     lea    -0x8(%rbp),%rcx
0x0000000000401471 <+12>:    lea    -0x4(%rbp),%rdx
0x0000000000401475 <+16>:    mov    $0x40332f,%esi
0x000000000040147a <+21>:    mov    $0x0,%eax
0x000000000040147f <+26>:    call   0x401110 <__isoc99_sscanf@plt>
```
- `lea -0x8(%rbp), %rcx`：传递 `&num2` 给 `sscanf`。
- `lea -0x4(%rbp), %rdx`：传递 `&num1` 给 `sscanf`。
- `mov $0x40332f, %esi`：格式字符串地址 `"%d %d"`。
- `call __isoc99_sscanf`：调用 `sscanf("%d %d", &num1, &num2)` 读取两个整数。

---

## **3. 检查输入**
```assembly
0x0000000000401484 <+31>:    cmp    $0x1,%eax
0x0000000000401487 <+34>:    jle    0x40149a <phase_3+53>
```
- **如果 `sscanf` 读取的整数数量 ≤ 1，调用 `explode_bomb()`，程序爆炸！**

---

## **4. 检查第一个输入是否在范围内**
```assembly
0x0000000000401489 <+36>:    mov    -0x4(%rbp),%eax
0x000000000040148c <+39>:    cmp    $0x7,%eax
0x000000000040148f <+42>:    ja     0x40150c <phase_3+167>
```
- `eax = num1`。
- 如果 `num1 > 7`，跳转到 `explode_bomb()` 直接爆炸。

---

## **5. 计算目标值**
```assembly
0x0000000000401491 <+44>:    mov    %eax,%eax
0x0000000000401493 <+46>:    jmp    *0x4031a0(,%rax,8)
```
- `jmp *0x4031a0(,%rax,8)`：**跳转到** `0x4031a0 + (num1 * 8)` 处的代码。
- `0x4031a0` 是一个**跳转表**，存放 8 个不同的分支地址，每个地址占 8 字节。

不同分支：
```assembly
0x00000000004014db <+118>:   mov    $0x111,%eax   # case 0
0x00000000004014e2 <+125>:   mov    $0x0,%eax     # case 1
0x00000000004014e9 <+132>:   mov    $0x0,%eax     # case 2
0x00000000004014f0 <+139>:   mov    $0x0,%eax     # case 3
0x00000000004014f7 <+146>:   mov    $0x0,%eax     # case 4
0x00000000004014fe <+153>:   mov    $0x0,%eax     # case 5
0x0000000000401505 <+160>:   mov    $0x0,%eax     # case 6
```
- `eax` 存储计算出的目标值。
- **大部分分支 `eax = 0`，但 `case 0` 设定 `eax = 0x111`**。

---

## **6. 检查第二个输入**
```assembly
0x00000000004014c9 <+100>:   cmpl   $0x5,-0x4(%rbp)
0x00000000004014cd <+104>:   jg     0x4014d4 <phase_3+111>
```
- `if (num1 > 5)`，直接 `explode_bomb()`。

```assembly
0x00000000004014cf <+106>:   cmp    %eax,-0x8(%rbp)
0x00000000004014d2 <+109>:   je     0x4014d9 <phase_3+116>
```
- **如果 `num2 != 目标值`，则爆炸**。

---

## **7. 结束函数**
```assembly
0x00000000004014d9 <+116>:   leave
0x00000000004014da <+117>:   ret
```
- **成功通过本关，函数返回**。

---

# 4. 二分查找递归