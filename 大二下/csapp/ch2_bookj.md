# 2.1
## 2.1.2
对于一个字长为w位的机器而言，虚拟地址的范围为$0 - 2^w-1$,程序最多访问$2^w$个字节

## 2.1.7
确定一个位级表达式的结果最好方式,把十六进制转换成二进制并执行二进制运算,然后再转换成十六进制

x & 0xFF  生成一个由最低有效字节组成的值

**练习2.12**
x的最低有效字节,其他位置均为0 
## 2.1.9
移位运算 右移分为 逻辑右移(填0) 与 算数右移(填1)
有符号数 基本都是算数右移
无符号数 必须是逻辑右移
00000101
00001010
01、

### 2.2 整数
## 2.2.1 整型数据类型
long与机器字长有关,32位为4字节,64位为8字节
取值范围:负数比正数范围大一

## 2.2.3 补码编码
补码编码不对称$|TMin|=|TMax|+1$
同一字长下,最大无符号数值刚好比补码最大值大一$UMax=2Tmax+1$
\<limits.h>中定义了INT_MAX,INT_MIN,UINT_MAX,对应TMax,TMin,UMax
补码求解,把无符号整型编码取反加1
1001   -   0111

## 2.2.4 有符号数与无符号数的转换
补码转无符号数
$TMin_w<=x<=TMax_w:T2U_w(x)=x+2^2,x<0;x,x>=0$

无符号数转补码
...

通常大多数数字默认有符号
当执行一个运算时,如果他的一个运算数时有符号数而另一个是无符号数,那么c语言会隐式地将有符号强制类型转换为无符号数,并假设这两个数是非负的.此时对于标准的算数运算并无多大差异,但是对于\<和>这样的关系运算符来说就有差异了
